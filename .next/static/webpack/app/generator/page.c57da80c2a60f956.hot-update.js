"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/generator/page",{

/***/ "(app-pages-browser)/./src/lib/imageProcessing.ts":
/*!************************************!*\
  !*** ./src/lib/imageProcessing.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeColoringPageQuality: function() { return /* binding */ analyzeColoringPageQuality; },\n/* harmony export */   assessImageQuality: function() { return /* binding */ assessImageQuality; },\n/* harmony export */   enhancePrompt: function() { return /* binding */ enhancePrompt; },\n/* harmony export */   getCategoryNegativePrompts: function() { return /* binding */ getCategoryNegativePrompts; },\n/* harmony export */   getOptimalSeedRange: function() { return /* binding */ getOptimalSeedRange; },\n/* harmony export */   getOptimizedParams: function() { return /* binding */ getOptimizedParams; },\n/* harmony export */   getSuggestedPromptEnhancements: function() { return /* binding */ getSuggestedPromptEnhancements; },\n/* harmony export */   optimizeImage: function() { return /* binding */ optimizeImage; },\n/* harmony export */   recursivePromptOptimization: function() { return /* binding */ recursivePromptOptimization; }\n/* harmony export */ });\n/**\n * Image Processing Service for Coloring Pages\n * \n * This service handles image optimization specifically for coloring pages\n * - Ensures clean black outlines on white background\n * - Optimizes for printing\n * - Provides image analysis and enhancement\n */ /**\n * Image processing utility functions for AI coloring page generation\n */ /**\n * Get optimal seed range for specific content types\n * Different seed ranges produce better results for different content types\n */ function getOptimalSeedRange(category) {\n    const seedRanges = {\n        animals: [\n            120000,\n            140000\n        ],\n        nature: [\n            140000,\n            160000\n        ],\n        fantasy: [\n            160000,\n            180000\n        ],\n        vehicles: [\n            180000,\n            200000\n        ],\n        patterns: [\n            200000,\n            220000\n        ],\n        default: [\n            100000,\n            999999\n        ]\n    };\n    return seedRanges[category] || seedRanges.default;\n}\n/**\n * Get optimized parameters for specific image types\n */ function getOptimizedParams(complexity) {\n    const baseParams = {\n        num_inference_steps: 30,\n        guidance_scale: 7.5\n    };\n    const complexityParams = {\n        simple: {\n            num_inference_steps: 28,\n            guidance_scale: 7.0\n        },\n        medium: baseParams,\n        detailed: {\n            num_inference_steps: 32,\n            guidance_scale: 8.2\n        }\n    };\n    return complexityParams[complexity] || baseParams;\n}\n/**\n * Get category-specific negative prompts to improve generation quality\n */ function getCategoryNegativePrompts(category) {\n    const baseNegative = \"photo, realistic, shading, grayscale, gradient, 3d, color, watercolor, painting, crosshatching, complex texture, busy background\";\n    const categoryNegatives = {\n        animals: \"\".concat(baseNegative, \", human, people, text, realistic fur, realistic eyes\"),\n        nature: \"\".concat(baseNegative, \", people, buildings, vehicles, complex patterns\"),\n        fantasy: \"\".concat(baseNegative, \", realistic, modern, urban, technical\"),\n        vehicles: \"\".concat(baseNegative, \", organic shapes, people, animals, nature\"),\n        patterns: \"\".concat(baseNegative, \", specific objects, scenes, figures\"),\n        default: baseNegative\n    };\n    return categoryNegatives[category] || categoryNegatives.default;\n}\n/**\n * Get suggested prompt enhancements based on user input\n */ function getSuggestedPromptEnhancements(userPrompt) {\n    const suggestions = [];\n    // Check for common improvement opportunities\n    if (userPrompt.length < 10) {\n        suggestions.push(\"Add more details to your description for better results\");\n    }\n    if (!userPrompt.toLowerCase().includes(\"background\")) {\n        suggestions.push(\"Consider describing the background or setting\");\n    }\n    if (!userPrompt.match(/position|pose|standing|sitting/i)) {\n        suggestions.push(\"Specify the position or pose of the main subject\");\n    }\n    // Add general suggestions if no specific ones were found\n    if (suggestions.length === 0) {\n        suggestions.push(\"Try adding adjectives to describe the mood or style\");\n        suggestions.push(\"Consider specifying the perspective (e.g., front view, side view)\");\n    }\n    return suggestions;\n}\n// Function to determine if an image has good contrast for coloring\nfunction analyzeColoringPageQuality(imageData) {\n    // This would normally use canvas and image processing libraries\n    // For demonstration, we're providing a simulated analysis\n    // In a real implementation, this would:\n    // 1. Measure the contrast between lines and background\n    // 2. Check for presence of grayscale elements (should be pure black/white)\n    // 3. Analyze line thickness and consistency\n    // 4. Evaluate balance of white space vs. coloring areas\n    // Simulated score between 0-100\n    const score = 85;\n    const feedback = [\n        \"Good contrast between lines and background\",\n        \"Clean black outlines detected\",\n        \"Appropriate line thickness for coloring\",\n        \"Good balance of detail and open spaces\"\n    ];\n    return {\n        score,\n        feedback\n    };\n}\n// 提示词增强引擎\nfunction enhancePrompt(basePrompt, category) {\n    const styleModifiers = {\n        animals: \"(lineart:1.2), (clean lines:1.1), (single line thickness:1.05), simplified animal drawing\",\n        nature: \"(lineart:1.2), (clean lines:1.1), (botanical illustration:1.05)\",\n        fantasy: \"(lineart:1.2), (clean lines:1.1), (storybook illustration:1.05)\",\n        vehicles: \"(lineart:1.2), (clean lines:1.1), (technical drawing:1.05)\",\n        patterns: \"(lineart:1.2), (clean lines:1.1), (geometric pattern:1.05)\",\n        default: \"(lineart:1.2), (clean lines:1.1), (single line thickness:1.05)\"\n    };\n    return \"\".concat(basePrompt, \" \").concat(styleModifiers[category] || styleModifiers.default);\n}\n// 图像后处理优化\nasync function optimizeImage(imageData) {\n    // 这里将来可以添加实际的图像处理逻辑\n    // 例如：边缘检测、背景纯白化、线条黑化等\n    return imageData;\n}\n// 递归提示优化\nfunction recursivePromptOptimization(basePrompt, previousResults) {\n    let attempts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    const maxAttempts = 3;\n    if (attempts >= maxAttempts) {\n        return basePrompt;\n    }\n    // 基于之前的结果调整提示词\n    let optimizedPrompt = basePrompt;\n    if (previousResults.length > 0) {\n        // 这里可以添加基于之前结果的优化逻辑\n        optimizedPrompt += \" (high quality:1.2), (clear lines:1.1)\";\n    }\n    return optimizedPrompt;\n}\n// 图像质量评估\nfunction assessImageQuality(imageData) {\n    return new Promise((resolve)=>{\n        // 这里将来可以添加实际的质量评估逻辑\n        // 返回0-10的质量分数\n        resolve(8.5);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaW1hZ2VQcm9jZXNzaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FFRDs7Q0FFQyxHQUVEOzs7Q0FHQyxHQUdNLFNBQVNBLG9CQUFvQkMsUUFBc0I7SUFDeEQsTUFBTUMsYUFBYTtRQUNqQkMsU0FBUztZQUFDO1lBQVE7U0FBTztRQUN6QkMsUUFBUTtZQUFDO1lBQVE7U0FBTztRQUN4QkMsU0FBUztZQUFDO1lBQVE7U0FBTztRQUN6QkMsVUFBVTtZQUFDO1lBQVE7U0FBTztRQUMxQkMsVUFBVTtZQUFDO1lBQVE7U0FBTztRQUMxQkMsU0FBUztZQUFDO1lBQVE7U0FBTztJQUMzQjtJQUVBLE9BQU9OLFVBQVUsQ0FBQ0QsU0FBUyxJQUFJQyxXQUFXTSxPQUFPO0FBQ25EO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxtQkFBbUJDLFVBQWtCO0lBQ25ELE1BQU1DLGFBQWE7UUFDakJDLHFCQUFxQjtRQUNyQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsTUFBTUMsbUJBQW1CO1FBQ3ZCQyxRQUFRO1lBQ05ILHFCQUFxQjtZQUNyQkMsZ0JBQWdCO1FBQ2xCO1FBQ0FHLFFBQVFMO1FBQ1JNLFVBQVU7WUFDUkwscUJBQXFCO1lBQ3JCQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLE9BQU9DLGdCQUFnQixDQUFDSixXQUFXLElBQUlDO0FBQ3pDO0FBRUE7O0NBRUMsR0FDTSxTQUFTTywyQkFBMkJqQixRQUFzQjtJQUMvRCxNQUFNa0IsZUFBZTtJQUVyQixNQUFNQyxvQkFBb0I7UUFDeEJqQixTQUFTLEdBQWdCLE9BQWJnQixjQUFhO1FBQ3pCZixRQUFRLEdBQWdCLE9BQWJlLGNBQWE7UUFDeEJkLFNBQVMsR0FBZ0IsT0FBYmMsY0FBYTtRQUN6QmIsVUFBVSxHQUFnQixPQUFiYSxjQUFhO1FBQzFCWixVQUFVLEdBQWdCLE9BQWJZLGNBQWE7UUFDMUJYLFNBQVNXO0lBQ1g7SUFFQSxPQUFPQyxpQkFBaUIsQ0FBQ25CLFNBQVMsSUFBSW1CLGtCQUFrQlosT0FBTztBQUNqRTtBQUVBOztDQUVDLEdBQ00sU0FBU2EsK0JBQStCQyxVQUFrQjtJQUMvRCxNQUFNQyxjQUFjLEVBQUU7SUFFdEIsNkNBQTZDO0lBQzdDLElBQUlELFdBQVdFLE1BQU0sR0FBRyxJQUFJO1FBQzFCRCxZQUFZRSxJQUFJLENBQUM7SUFDbkI7SUFFQSxJQUFJLENBQUNILFdBQVdJLFdBQVcsR0FBR0MsUUFBUSxDQUFDLGVBQWU7UUFDcERKLFlBQVlFLElBQUksQ0FBQztJQUNuQjtJQUVBLElBQUksQ0FBQ0gsV0FBV00sS0FBSyxDQUFDLG9DQUFvQztRQUN4REwsWUFBWUUsSUFBSSxDQUFDO0lBQ25CO0lBRUEseURBQXlEO0lBQ3pELElBQUlGLFlBQVlDLE1BQU0sS0FBSyxHQUFHO1FBQzVCRCxZQUFZRSxJQUFJLENBQUM7UUFDakJGLFlBQVlFLElBQUksQ0FBQztJQUNuQjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQSxtRUFBbUU7QUFDNUQsU0FBU00sMkJBQTJCQyxTQUFjO0lBSXZELGdFQUFnRTtJQUNoRSwwREFBMEQ7SUFFMUQsd0NBQXdDO0lBQ3hDLHVEQUF1RDtJQUN2RCwyRUFBMkU7SUFDM0UsNENBQTRDO0lBQzVDLHdEQUF3RDtJQUV4RCxnQ0FBZ0M7SUFDaEMsTUFBTUMsUUFBUTtJQUVkLE1BQU1DLFdBQVc7UUFDZjtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsT0FBTztRQUFFRDtRQUFPQztJQUFTO0FBQzNCO0FBRUEsVUFBVTtBQUNILFNBQVNDLGNBQWNDLFVBQWtCLEVBQUVqQyxRQUFzQjtJQUN0RSxNQUFNa0MsaUJBQWlCO1FBQ3JCaEMsU0FBUztRQUNUQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUVBLE9BQU8sR0FBaUIyQixPQUFkRCxZQUFXLEtBQXNELE9BQW5EQyxjQUFjLENBQUNsQyxTQUFTLElBQUlrQyxlQUFlM0IsT0FBTztBQUM1RTtBQUVBLFVBQVU7QUFDSCxlQUFlNEIsY0FBY04sU0FBZTtJQUNqRCxvQkFBb0I7SUFDcEIsc0JBQXNCO0lBQ3RCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTO0FBQ0YsU0FBU08sNEJBQ2RILFVBQWtCLEVBQ2xCSSxlQUF5QjtRQUN6QkMsV0FBQUEsaUVBQW1CO0lBRW5CLE1BQU1DLGNBQWM7SUFDcEIsSUFBSUQsWUFBWUMsYUFBYTtRQUMzQixPQUFPTjtJQUNUO0lBRUEsZUFBZTtJQUNmLElBQUlPLGtCQUFrQlA7SUFDdEIsSUFBSUksZ0JBQWdCZCxNQUFNLEdBQUcsR0FBRztRQUM5QixvQkFBb0I7UUFDcEJpQixtQkFBbUI7SUFDckI7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBUztBQUNGLFNBQVNDLG1CQUFtQlosU0FBZTtJQUNoRCxPQUFPLElBQUlhLFFBQVEsQ0FBQ0M7UUFDbEIsb0JBQW9CO1FBQ3BCLGNBQWM7UUFDZEEsUUFBUTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9pbWFnZVByb2Nlc3NpbmcudHM/ODBmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEltYWdlIFByb2Nlc3NpbmcgU2VydmljZSBmb3IgQ29sb3JpbmcgUGFnZXNcbiAqIFxuICogVGhpcyBzZXJ2aWNlIGhhbmRsZXMgaW1hZ2Ugb3B0aW1pemF0aW9uIHNwZWNpZmljYWxseSBmb3IgY29sb3JpbmcgcGFnZXNcbiAqIC0gRW5zdXJlcyBjbGVhbiBibGFjayBvdXRsaW5lcyBvbiB3aGl0ZSBiYWNrZ3JvdW5kXG4gKiAtIE9wdGltaXplcyBmb3IgcHJpbnRpbmdcbiAqIC0gUHJvdmlkZXMgaW1hZ2UgYW5hbHlzaXMgYW5kIGVuaGFuY2VtZW50XG4gKi9cblxuLyoqXG4gKiBJbWFnZSBwcm9jZXNzaW5nIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBBSSBjb2xvcmluZyBwYWdlIGdlbmVyYXRpb25cbiAqL1xuXG4vKipcbiAqIEdldCBvcHRpbWFsIHNlZWQgcmFuZ2UgZm9yIHNwZWNpZmljIGNvbnRlbnQgdHlwZXNcbiAqIERpZmZlcmVudCBzZWVkIHJhbmdlcyBwcm9kdWNlIGJldHRlciByZXN1bHRzIGZvciBkaWZmZXJlbnQgY29udGVudCB0eXBlc1xuICovXG5pbXBvcnQgeyBDYXRlZ29yeVR5cGUgfSBmcm9tICdAL3R5cGVzL2ltYWdlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGltYWxTZWVkUmFuZ2UoY2F0ZWdvcnk6IENhdGVnb3J5VHlwZSk6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCBzZWVkUmFuZ2VzID0ge1xuICAgIGFuaW1hbHM6IFsxMjAwMDAsIDE0MDAwMF0sXG4gICAgbmF0dXJlOiBbMTQwMDAwLCAxNjAwMDBdLFxuICAgIGZhbnRhc3k6IFsxNjAwMDAsIDE4MDAwMF0sXG4gICAgdmVoaWNsZXM6IFsxODAwMDAsIDIwMDAwMF0sXG4gICAgcGF0dGVybnM6IFsyMDAwMDAsIDIyMDAwMF0sXG4gICAgZGVmYXVsdDogWzEwMDAwMCwgOTk5OTk5XVxuICB9O1xuICBcbiAgcmV0dXJuIHNlZWRSYW5nZXNbY2F0ZWdvcnldIHx8IHNlZWRSYW5nZXMuZGVmYXVsdDtcbn1cblxuLyoqXG4gKiBHZXQgb3B0aW1pemVkIHBhcmFtZXRlcnMgZm9yIHNwZWNpZmljIGltYWdlIHR5cGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHRpbWl6ZWRQYXJhbXMoY29tcGxleGl0eTogc3RyaW5nKSB7XG4gIGNvbnN0IGJhc2VQYXJhbXMgPSB7XG4gICAgbnVtX2luZmVyZW5jZV9zdGVwczogMzAsXG4gICAgZ3VpZGFuY2Vfc2NhbGU6IDcuNSxcbiAgfTtcblxuICBjb25zdCBjb21wbGV4aXR5UGFyYW1zID0ge1xuICAgIHNpbXBsZToge1xuICAgICAgbnVtX2luZmVyZW5jZV9zdGVwczogMjgsXG4gICAgICBndWlkYW5jZV9zY2FsZTogNy4wLFxuICAgIH0sXG4gICAgbWVkaXVtOiBiYXNlUGFyYW1zLFxuICAgIGRldGFpbGVkOiB7XG4gICAgICBudW1faW5mZXJlbmNlX3N0ZXBzOiAzMixcbiAgICAgIGd1aWRhbmNlX3NjYWxlOiA4LjIsXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb21wbGV4aXR5UGFyYW1zW2NvbXBsZXhpdHldIHx8IGJhc2VQYXJhbXM7XG59XG5cbi8qKlxuICogR2V0IGNhdGVnb3J5LXNwZWNpZmljIG5lZ2F0aXZlIHByb21wdHMgdG8gaW1wcm92ZSBnZW5lcmF0aW9uIHF1YWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhdGVnb3J5TmVnYXRpdmVQcm9tcHRzKGNhdGVnb3J5OiBDYXRlZ29yeVR5cGUpOiBzdHJpbmcge1xuICBjb25zdCBiYXNlTmVnYXRpdmUgPSAncGhvdG8sIHJlYWxpc3RpYywgc2hhZGluZywgZ3JheXNjYWxlLCBncmFkaWVudCwgM2QsIGNvbG9yLCB3YXRlcmNvbG9yLCBwYWludGluZywgY3Jvc3NoYXRjaGluZywgY29tcGxleCB0ZXh0dXJlLCBidXN5IGJhY2tncm91bmQnO1xuICBcbiAgY29uc3QgY2F0ZWdvcnlOZWdhdGl2ZXMgPSB7XG4gICAgYW5pbWFsczogYCR7YmFzZU5lZ2F0aXZlfSwgaHVtYW4sIHBlb3BsZSwgdGV4dCwgcmVhbGlzdGljIGZ1ciwgcmVhbGlzdGljIGV5ZXNgLFxuICAgIG5hdHVyZTogYCR7YmFzZU5lZ2F0aXZlfSwgcGVvcGxlLCBidWlsZGluZ3MsIHZlaGljbGVzLCBjb21wbGV4IHBhdHRlcm5zYCxcbiAgICBmYW50YXN5OiBgJHtiYXNlTmVnYXRpdmV9LCByZWFsaXN0aWMsIG1vZGVybiwgdXJiYW4sIHRlY2huaWNhbGAsXG4gICAgdmVoaWNsZXM6IGAke2Jhc2VOZWdhdGl2ZX0sIG9yZ2FuaWMgc2hhcGVzLCBwZW9wbGUsIGFuaW1hbHMsIG5hdHVyZWAsXG4gICAgcGF0dGVybnM6IGAke2Jhc2VOZWdhdGl2ZX0sIHNwZWNpZmljIG9iamVjdHMsIHNjZW5lcywgZmlndXJlc2AsXG4gICAgZGVmYXVsdDogYmFzZU5lZ2F0aXZlXG4gIH07XG5cbiAgcmV0dXJuIGNhdGVnb3J5TmVnYXRpdmVzW2NhdGVnb3J5XSB8fCBjYXRlZ29yeU5lZ2F0aXZlcy5kZWZhdWx0O1xufVxuXG4vKipcbiAqIEdldCBzdWdnZXN0ZWQgcHJvbXB0IGVuaGFuY2VtZW50cyBiYXNlZCBvbiB1c2VyIGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdWdnZXN0ZWRQcm9tcHRFbmhhbmNlbWVudHModXNlclByb21wdDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBzdWdnZXN0aW9ucyA9IFtdO1xuXG4gIC8vIENoZWNrIGZvciBjb21tb24gaW1wcm92ZW1lbnQgb3Bwb3J0dW5pdGllc1xuICBpZiAodXNlclByb21wdC5sZW5ndGggPCAxMCkge1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0FkZCBtb3JlIGRldGFpbHMgdG8geW91ciBkZXNjcmlwdGlvbiBmb3IgYmV0dGVyIHJlc3VsdHMnKTtcbiAgfVxuICBcbiAgaWYgKCF1c2VyUHJvbXB0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2JhY2tncm91bmQnKSkge1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0NvbnNpZGVyIGRlc2NyaWJpbmcgdGhlIGJhY2tncm91bmQgb3Igc2V0dGluZycpO1xuICB9XG4gIFxuICBpZiAoIXVzZXJQcm9tcHQubWF0Y2goL3Bvc2l0aW9ufHBvc2V8c3RhbmRpbmd8c2l0dGluZy9pKSkge1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goJ1NwZWNpZnkgdGhlIHBvc2l0aW9uIG9yIHBvc2Ugb2YgdGhlIG1haW4gc3ViamVjdCcpO1xuICB9XG4gIFxuICAvLyBBZGQgZ2VuZXJhbCBzdWdnZXN0aW9ucyBpZiBubyBzcGVjaWZpYyBvbmVzIHdlcmUgZm91bmRcbiAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goJ1RyeSBhZGRpbmcgYWRqZWN0aXZlcyB0byBkZXNjcmliZSB0aGUgbW9vZCBvciBzdHlsZScpO1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0NvbnNpZGVyIHNwZWNpZnlpbmcgdGhlIHBlcnNwZWN0aXZlIChlLmcuLCBmcm9udCB2aWV3LCBzaWRlIHZpZXcpJyk7XG4gIH1cbiAgXG4gIHJldHVybiBzdWdnZXN0aW9ucztcbn1cblxuLy8gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGFuIGltYWdlIGhhcyBnb29kIGNvbnRyYXN0IGZvciBjb2xvcmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVDb2xvcmluZ1BhZ2VRdWFsaXR5KGltYWdlRGF0YTogYW55KToge1xuICBzY29yZTogbnVtYmVyO1xuICBmZWVkYmFjazogc3RyaW5nW107XG59IHtcbiAgLy8gVGhpcyB3b3VsZCBub3JtYWxseSB1c2UgY2FudmFzIGFuZCBpbWFnZSBwcm9jZXNzaW5nIGxpYnJhcmllc1xuICAvLyBGb3IgZGVtb25zdHJhdGlvbiwgd2UncmUgcHJvdmlkaW5nIGEgc2ltdWxhdGVkIGFuYWx5c2lzXG4gIFxuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQ6XG4gIC8vIDEuIE1lYXN1cmUgdGhlIGNvbnRyYXN0IGJldHdlZW4gbGluZXMgYW5kIGJhY2tncm91bmRcbiAgLy8gMi4gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGdyYXlzY2FsZSBlbGVtZW50cyAoc2hvdWxkIGJlIHB1cmUgYmxhY2svd2hpdGUpXG4gIC8vIDMuIEFuYWx5emUgbGluZSB0aGlja25lc3MgYW5kIGNvbnNpc3RlbmN5XG4gIC8vIDQuIEV2YWx1YXRlIGJhbGFuY2Ugb2Ygd2hpdGUgc3BhY2UgdnMuIGNvbG9yaW5nIGFyZWFzXG4gIFxuICAvLyBTaW11bGF0ZWQgc2NvcmUgYmV0d2VlbiAwLTEwMFxuICBjb25zdCBzY29yZSA9IDg1O1xuICBcbiAgY29uc3QgZmVlZGJhY2sgPSBbXG4gICAgXCJHb29kIGNvbnRyYXN0IGJldHdlZW4gbGluZXMgYW5kIGJhY2tncm91bmRcIixcbiAgICBcIkNsZWFuIGJsYWNrIG91dGxpbmVzIGRldGVjdGVkXCIsXG4gICAgXCJBcHByb3ByaWF0ZSBsaW5lIHRoaWNrbmVzcyBmb3IgY29sb3JpbmdcIixcbiAgICBcIkdvb2QgYmFsYW5jZSBvZiBkZXRhaWwgYW5kIG9wZW4gc3BhY2VzXCIsXG4gIF07XG4gIFxuICByZXR1cm4geyBzY29yZSwgZmVlZGJhY2sgfTtcbn1cblxuLy8g5o+Q56S66K+N5aKe5by65byV5pOOXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZVByb21wdChiYXNlUHJvbXB0OiBzdHJpbmcsIGNhdGVnb3J5OiBDYXRlZ29yeVR5cGUpOiBzdHJpbmcge1xuICBjb25zdCBzdHlsZU1vZGlmaWVycyA9IHtcbiAgICBhbmltYWxzOiAnKGxpbmVhcnQ6MS4yKSwgKGNsZWFuIGxpbmVzOjEuMSksIChzaW5nbGUgbGluZSB0aGlja25lc3M6MS4wNSksIHNpbXBsaWZpZWQgYW5pbWFsIGRyYXdpbmcnLFxuICAgIG5hdHVyZTogJyhsaW5lYXJ0OjEuMiksIChjbGVhbiBsaW5lczoxLjEpLCAoYm90YW5pY2FsIGlsbHVzdHJhdGlvbjoxLjA1KScsXG4gICAgZmFudGFzeTogJyhsaW5lYXJ0OjEuMiksIChjbGVhbiBsaW5lczoxLjEpLCAoc3Rvcnlib29rIGlsbHVzdHJhdGlvbjoxLjA1KScsXG4gICAgdmVoaWNsZXM6ICcobGluZWFydDoxLjIpLCAoY2xlYW4gbGluZXM6MS4xKSwgKHRlY2huaWNhbCBkcmF3aW5nOjEuMDUpJyxcbiAgICBwYXR0ZXJuczogJyhsaW5lYXJ0OjEuMiksIChjbGVhbiBsaW5lczoxLjEpLCAoZ2VvbWV0cmljIHBhdHRlcm46MS4wNSknLFxuICAgIGRlZmF1bHQ6ICcobGluZWFydDoxLjIpLCAoY2xlYW4gbGluZXM6MS4xKSwgKHNpbmdsZSBsaW5lIHRoaWNrbmVzczoxLjA1KSdcbiAgfTtcblxuICByZXR1cm4gYCR7YmFzZVByb21wdH0gJHtzdHlsZU1vZGlmaWVyc1tjYXRlZ29yeV0gfHwgc3R5bGVNb2RpZmllcnMuZGVmYXVsdH1gO1xufVxuXG4vLyDlm77lg4/lkI7lpITnkIbkvJjljJZcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcHRpbWl6ZUltYWdlKGltYWdlRGF0YTogQmxvYik6IFByb21pc2U8QmxvYj4ge1xuICAvLyDov5nph4zlsIbmnaXlj6/ku6Xmt7vliqDlrp7pmYXnmoTlm77lg4/lpITnkIbpgLvovpFcbiAgLy8g5L6L5aaC77ya6L6557yY5qOA5rWL44CB6IOM5pmv57qv55m95YyW44CB57q/5p2h6buR5YyW562JXG4gIHJldHVybiBpbWFnZURhdGE7XG59XG5cbi8vIOmAkuW9kuaPkOekuuS8mOWMllxuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVByb21wdE9wdGltaXphdGlvbihcbiAgYmFzZVByb21wdDogc3RyaW5nLFxuICBwcmV2aW91c1Jlc3VsdHM6IHN0cmluZ1tdLFxuICBhdHRlbXB0czogbnVtYmVyID0gMFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbWF4QXR0ZW1wdHMgPSAzO1xuICBpZiAoYXR0ZW1wdHMgPj0gbWF4QXR0ZW1wdHMpIHtcbiAgICByZXR1cm4gYmFzZVByb21wdDtcbiAgfVxuXG4gIC8vIOWfuuS6juS5i+WJjeeahOe7k+aenOiwg+aVtOaPkOekuuivjVxuICBsZXQgb3B0aW1pemVkUHJvbXB0ID0gYmFzZVByb21wdDtcbiAgaWYgKHByZXZpb3VzUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgLy8g6L+Z6YeM5Y+v5Lul5re75Yqg5Z+65LqO5LmL5YmN57uT5p6c55qE5LyY5YyW6YC76L6RXG4gICAgb3B0aW1pemVkUHJvbXB0ICs9ICcgKGhpZ2ggcXVhbGl0eToxLjIpLCAoY2xlYXIgbGluZXM6MS4xKSc7XG4gIH1cblxuICByZXR1cm4gb3B0aW1pemVkUHJvbXB0O1xufVxuXG4vLyDlm77lg4/otKjph4/or4TkvLBcbmV4cG9ydCBmdW5jdGlvbiBhc3Nlc3NJbWFnZVF1YWxpdHkoaW1hZ2VEYXRhOiBCbG9iKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgLy8g6L+Z6YeM5bCG5p2l5Y+v5Lul5re75Yqg5a6e6ZmF55qE6LSo6YeP6K+E5Lyw6YC76L6RXG4gICAgLy8g6L+U5ZueMC0xMOeahOi0qOmHj+WIhuaVsFxuICAgIHJlc29sdmUoOC41KTtcbiAgfSk7XG59ICJdLCJuYW1lcyI6WyJnZXRPcHRpbWFsU2VlZFJhbmdlIiwiY2F0ZWdvcnkiLCJzZWVkUmFuZ2VzIiwiYW5pbWFscyIsIm5hdHVyZSIsImZhbnRhc3kiLCJ2ZWhpY2xlcyIsInBhdHRlcm5zIiwiZGVmYXVsdCIsImdldE9wdGltaXplZFBhcmFtcyIsImNvbXBsZXhpdHkiLCJiYXNlUGFyYW1zIiwibnVtX2luZmVyZW5jZV9zdGVwcyIsImd1aWRhbmNlX3NjYWxlIiwiY29tcGxleGl0eVBhcmFtcyIsInNpbXBsZSIsIm1lZGl1bSIsImRldGFpbGVkIiwiZ2V0Q2F0ZWdvcnlOZWdhdGl2ZVByb21wdHMiLCJiYXNlTmVnYXRpdmUiLCJjYXRlZ29yeU5lZ2F0aXZlcyIsImdldFN1Z2dlc3RlZFByb21wdEVuaGFuY2VtZW50cyIsInVzZXJQcm9tcHQiLCJzdWdnZXN0aW9ucyIsImxlbmd0aCIsInB1c2giLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwibWF0Y2giLCJhbmFseXplQ29sb3JpbmdQYWdlUXVhbGl0eSIsImltYWdlRGF0YSIsInNjb3JlIiwiZmVlZGJhY2siLCJlbmhhbmNlUHJvbXB0IiwiYmFzZVByb21wdCIsInN0eWxlTW9kaWZpZXJzIiwib3B0aW1pemVJbWFnZSIsInJlY3Vyc2l2ZVByb21wdE9wdGltaXphdGlvbiIsInByZXZpb3VzUmVzdWx0cyIsImF0dGVtcHRzIiwibWF4QXR0ZW1wdHMiLCJvcHRpbWl6ZWRQcm9tcHQiLCJhc3Nlc3NJbWFnZVF1YWxpdHkiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/imageProcessing.ts\n"));

/***/ })

});